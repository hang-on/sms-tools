<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SMS Indexed PNG – Color Folder</title>
  <style>
    :root{--bg:#0b0d10;--panel:#12161b;--muted:#a7b0be;--accent:#2dd4bf;--border:#1f2937}
    html,body{height:100%}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,"Noto Sans",sans-serif;background:var(--bg);color:#e5e7eb}
    header{padding:18px 20px;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:14px}
    header h1{font-size:18px;margin:0;font-weight:650;letter-spacing:.2px}
    header .sub{color:var(--muted);font-size:12px}
    main{padding:16px;display:grid;grid-template-columns:360px 1fr;gap:16px}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .left{padding:14px}
    .controls{display:flex;flex-direction:column;gap:10px}
    .drop{border:1.5px dashed #334155;border-radius:12px;padding:16px;text-align:center;color:var(--muted);background:#0f1318}
    .drop.drag{border-color:var(--accent);color:#d1fae5}
    input[type=file]{width:100%}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    button{appearance:none;border:1px solid #334155;background:#0f172a;color:#e5e7eb;padding:10px 12px;border-radius:10px;cursor:pointer;font-weight:600}
    button:disabled{opacity:.5;cursor:not-allowed}
    .palette{display:grid;grid-template-columns:repeat(8, 1fr);gap:6px;margin-top:8px}
    .sw{height:22px;border-radius:6px;border:1px solid rgba(255,255,255,.08);position:relative;cursor:pointer}
    .sw .idx{position:absolute;inset:auto 6px 2px auto;font-size:10px;color:#0b0d10;background:#e5e7eb;border-radius:4px;padding:0 4px}
    .sw.selA{outline:2px solid #22d3ee}
    .sw.selB{outline:2px dashed #f59e0b}
    .panel{border:1px solid var(--border);border-radius:12px;overflow:hidden}
    .panel h3{margin:0;padding:10px 12px;border-bottom:1px solid var(--border);background:#0e1319;font-size:13px;color:#cbd5e1}
    .panel .body{padding:12px}
    canvas{width:100%;height:auto;image-rendering:pixelated;background:#000}
    .meta{display:flex;gap:10px;flex-wrap:wrap;color:#a7b0be;font-size:12px;margin-top:8px}
    .note{color:#a7b0be;font-size:12px;margin-top:6px}
    .kbd{background:#0b1220;border:1px solid #1f2937;padding:1px 6px;border-radius:6px;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace}
  </style>
</head>
<body>
  <header class="card">
    <h1>SMS Indexed PNG – Color Folder</h1>
    <span class="sub">Load an indexed PNG (from the converter). Pick a target color, then a source color to <em>fold</em> source into target. Source entry is replaced with black. Undo and export supported.</span>
  </header>

  <main>
    <section class="left card">
      <div class="controls">
        <div class="drop" id="drop">
          <div><strong>Drop an indexed PNG here</strong> or use the file picker</div>
          <div class="meta">Must be <span class="kbd">color type 3</span> (indexed), 8-bit depth. Works with images from the previous tool.</div>
        </div>
        <input id="file" type="file" accept="image/png" />
        <div class="row">
          <button id="undo" disabled>Undo</button>
          <button id="save" disabled>Export reduced PNG</button>
        </div>
        <div class="note">Click a swatch to select <strong>Target A</strong> (highlighted), then another swatch as <strong>Source B</strong> to fold B → A. Pixels using B will now use A. Palette entry B becomes black.</div>
        <div id="palInfo" class="meta"></div>
        <div id="palette" class="palette"></div>
      </div>
    </section>

    <section class="right card">
      <div class="panel">
        <h3>Preview</h3>
        <div class="body">
          <canvas id="canvas"></canvas>
          <div id="imgMeta" class="meta"></div>
        </div>
      </div>
    </section>
  </main>

  <!-- ======= Minimal PNG writer (IHDR/PLTE/[tRNS]/IDAT/IEND) ======= -->
  <script>
    const CRC_TABLE = new Uint32Array(256); (function(){ for(let n=0;n<256;n++){ let c=n; for(let k=0;k<8;k++) c=(c&1)?(0xEDB88320^(c>>>1)):(c>>>1); CRC_TABLE[n]=c>>>0; } })();
    function crc32(buf, off=0, len=buf.length){ let c=0xFFFFFFFF; for(let i=off;i<off+len;i++) c = CRC_TABLE[(c ^ buf[i]) & 0xFF] ^ (c>>>8); return (c ^ 0xFFFFFFFF)>>>0; }
    const be32 = n => new Uint8Array([n>>>24 & 255, n>>>16 & 255, n>>>8 & 255, n & 255]);
    function chunk(typeStr, data){ const type=new TextEncoder().encode(typeStr); const len=be32(data.length); const out=new Uint8Array(12+data.length); out.set(len,0); out.set(type,4); out.set(data,8); const c=crc32(out,4,4+data.length); out.set(be32(c),8+data.length); return out; }
    function encodeIndexedPNG(indexBytes, width, height, palette, transparency){
      if(palette.length % 3 !== 0) throw new Error('Palette must be 3*N bytes');
      const N = palette.length/3; if(N<1||N>256) throw new Error('Palette entries must be 1..256');
      const sig = new Uint8Array([137,80,78,71,13,10,26,10]);
      const ihdr = new Uint8Array(13);
      ihdr.set(be32(width),0); ihdr.set(be32(height),4);
      ihdr[8]=8; ihdr[9]=3; ihdr[10]=0; ihdr[11]=0; ihdr[12]=0;
      const IHDR = chunk('IHDR', ihdr);
      const PLTE = chunk('PLTE', palette);
      const TRNS = (transparency && transparency.length>0) ? chunk('tRNS', transparency) : null;
      // raw scanlines (filter 0)
      const raw = new Uint8Array(height*(1+width));
      for(let y=0;y<height;y++){ raw[y*(width+1)]=0; raw.set(indexBytes.subarray(y*width,(y+1)*width), y*(width+1)+1); }
      // minimal zlib (stored blocks)
      const compressed = (function zlibStore(data){
        function adler32(buf){ let a=1,b=0; for(let i=0;i<buf.length;i++){ a=(a+buf[i])%65521; b=(b+a)%65521; } return ((b<<16)>>>0)|(a>>>0); }
        const CMF=0x78, FLG=0x01; const parts=[]; let pos=0;
        while(pos<data.length){ const len=Math.min(65535,data.length-pos); const isFinal=(pos+len===data.length)?1:0; parts.push(isFinal); parts.push(len&255,(len>>>8)&255,(~len)&255,((~len)>>>8)&255); for(let i=0;i<len;i++) parts.push(data[pos+i]); pos+=len; }
        const body=new Uint8Array(parts); const ad=adler32(data); const out=new Uint8Array(2+body.length+4);
        out[0]=CMF; out[1]=FLG; out.set(body,2); out[out.length-4]=(ad>>>24)&255; out[out.length-3]=(ad>>>16)&255; out[out.length-2]=(ad>>>8)&255; out[out.length-1]=ad&255; return out;
      })(raw);
      const IDAT = chunk('IDAT', compressed);
      const IEND = chunk('IEND', new Uint8Array());
      const totalLen = sig.length+IHDR.length+PLTE.length+(TRNS?TRNS.length:0)+IDAT.length+IEND.length;
      const png = new Uint8Array(totalLen);
      let o=0; png.set(sig,o); o+=sig.length; png.set(IHDR,o); o+=IHDR.length; png.set(PLTE,o); o+=PLTE.length; if(TRNS){ png.set(TRNS,o); o+=TRNS.length; } png.set(IDAT,o); o+=IDAT.length; png.set(IEND,o);
      return png;
    }
  </script>

  <!-- ======= App logic ======= -->
  <script>
    const drop = document.getElementById('drop');
    const fileInput = document.getElementById('file');
    const undoBtn = document.getElementById('undo');
    const saveBtn = document.getElementById('save');
    const paletteEl = document.getElementById('palette');
    const palInfo = document.getElementById('palInfo');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const imgMeta = document.getElementById('imgMeta');

    let width=0, height=0;
    let indices=null;           // Uint8Array (w*h) current indices
    let palette=null;           // Uint8Array (3*N)
    let trns=null;              // Uint8Array (N) or null

    let selA=null;              // target index
    let selB=null;              // source index

    const history=[];           // stack of {indices, palette, trns}

    function pushHistory(){
      history.push({
        indices: new Uint8Array(indices),
        palette: new Uint8Array(palette),
        trns: trns ? new Uint8Array(trns) : null,
      });
      undoBtn.disabled = history.length===0;
    }

    function undo(){
      if(history.length===0) return;
      const prev = history.pop();
      indices = prev.indices;
      palette = prev.palette;
      trns = prev.trns;
      selA = selB = null;
      renderUI();
      undoBtn.disabled = history.length===0;
    }

    function parsePNG(buf){
      const u8 = new Uint8Array(buf);
      // signature
      const sig=[137,80,78,71,13,10,26,10]; for(let i=0;i<8;i++){ if(u8[i]!==sig[i]) throw new Error('Not a PNG'); }
      let off=8; let gotIHDR=false; let plte=null; let trnsLocal=null;
      while(off < u8.length){
        const len = (u8[off]<<24)|(u8[off+1]<<16)|(u8[off+2]<<8)|u8[off+3]; off+=4;
        const type = String.fromCharCode(u8[off],u8[off+1],u8[off+2],u8[off+3]); off+=4;
        const dataOff=off; off+=len; off+=4; // skip CRC
        if(type==='IHDR'){
          gotIHDR=true; width=(u8[dataOff]<<24)|(u8[dataOff+1]<<16)|(u8[dataOff+2]<<8)|u8[dataOff+3]; height=(u8[dataOff+4]<<24)|(u8[dataOff+5]<<16)|(u8[dataOff+6]<<8)|u8[dataOff+7];
          const bitDepth=u8[dataOff+8]; const colorType=u8[dataOff+9];
          if(bitDepth!==8 || colorType!==3) throw new Error('PNG must be indexed (color type 3) with 8-bit depth.');
        } else if(type==='PLTE'){
          plte = u8.slice(dataOff, dataOff+len); // 3*N
        } else if(type==='tRNS'){
          trnsLocal = u8.slice(dataOff, dataOff+len); // N alphas
        } else if(type==='IEND'){
          break;
        }
      }
      if(!gotIHDR || !plte) throw new Error('Missing IHDR or PLTE.');
      palette = plte; trns = trnsLocal || null;
    }

    function loadImageAndIndices(file){
      return new Promise((resolve,reject)=>{
        // 1) Parse PLTE/tRNS + IHDR from ArrayBuffer
        const fr = new FileReader();
        fr.onload = () => { try{ parsePNG(fr.result); resolve(); } catch(e){ reject(e); } };
        fr.onerror = reject; fr.readAsArrayBuffer(file);
      }).then(()=> new Promise((resolve2,reject2)=>{
        // 2) Load rgba via <img> + offscreen canvas to reconstruct indices by exact PLTE match
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = ()=>{
          try{
            width = img.naturalWidth; height = img.naturalHeight;
            const rd = document.createElement('canvas'); rd.width = width; rd.height = height;
            const rctx = rd.getContext('2d', { willReadFrequently: true });
            rctx.drawImage(img,0,0);
            const rgba = rctx.getImageData(0,0,width,height).data;
            const map = new Map();
            for(let i=0;i<palette.length;i+=3){
              const r=palette[i], g=palette[i+1], b=palette[i+2];
              const key=(r<<16)|(g<<8)|b; map.set(key, i/3);
            }
            const out = new Uint8Array(width*height);
            for(let p=0,pi=0; p<rgba.length; p+=4,pi++){
              const a=rgba[p+3];
              if(a===0 && trns){
                let tIndex = trns.findIndex(v=>v===0);
                if(tIndex<0) tIndex=0;
                out[pi]=tIndex; continue;
              }
              const key=(rgba[p]<<16)|(rgba[p+1]<<8)|rgba[p+2];
              const idx = map.get(key);
              if(idx===undefined){ reject2(new Error('Pixel color not in PLTE. Image might not be indexed.')); return; }
              out[pi]=idx;
            }
            indices = out;
            renderUI();
            resolve2();
          } finally { URL.revokeObjectURL(url); }
        };
        img.onerror = ()=>{ URL.revokeObjectURL(url); reject2(new Error('Failed to load PNG')); };
        img.src = url;
      }));
    }

    function renderUI(){
      // draw preview from indices + palette
      const w=width, h=height; const im = new ImageData(w,h);
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          const idx = indices[y*w+x];
          const r=palette[idx*3], g=palette[idx*3+1], b=palette[idx*3+2];
          const o=((y*w+x)<<2); im.data[o]=r; im.data[o+1]=g; im.data[o+2]=b; im.data[o+3]=255;
        }
      }
      canvas.width=w; canvas.height=h; ctx.putImageData(im,0,0); imgMeta.textContent=`${w}×${h}px`;

      // compute used set & counts
      const N = palette.length/3; const counts=new Uint32Array(N);
      for(let i=0;i<indices.length;i++) counts[indices[i]]++;
      const used = []; for(let i=0;i<N;i++) if(counts[i]>0) used.push(i);
      palInfo.textContent = `${used.length} used colors • ${N} total`;

      // render used swatches
      paletteEl.innerHTML='';
      used.forEach(pi=>{
        const r=palette[pi*3], g=palette[pi*3+1], b=palette[pi*3+2];
        const sw=document.createElement('div'); sw.className='sw'; sw.style.background=`rgb(${r},${g},${b})`; sw.dataset.idx=String(pi);
        const tag=document.createElement('div'); tag.className='idx'; tag.textContent=pi; sw.appendChild(tag);
        if(selA===pi) sw.classList.add('selA'); else if(selB===pi) sw.classList.add('selB');
        sw.addEventListener('click',()=>onSwatchClick(pi));
        paletteEl.appendChild(sw);
      });

      undoBtn.disabled = history.length===0;
      saveBtn.disabled = false;
    }

    function onSwatchClick(pi){
      if(selA===null){ selA=pi; selB=null; renderUI(); return; }
      if(selA!==null && selB===null){
        if(pi===selA){ selA=null; renderUI(); return; }
        selB=pi; // have A and B -> fold B into A
        const A = selA, B = selB;
        foldBintoA(A, B);
        // Deselect both after a successful fold
        selA = null;
        selB = null;
        renderUI();
      }
    }

    function foldBintoA(A,B){
      if(A===B) return;
      pushHistory();
      // remap indices: all B -> A
      for(let i=0;i<indices.length;i++) if(indices[i]===B) indices[i]=A;
      // set palette entry B to black (0,0,0), keep A as-is
      palette[B*3]=0; palette[B*3+1]=0; palette[B*3+2]=0;
      // if transparency table exists, keep opaque by default
      if(trns){ if(trns[B]===undefined){} else trns[B]=255; }
      renderUI();
    }

    // ---------- Save ----------
    saveBtn.addEventListener('click', ()=>{
      if(!indices || !palette){ alert('Load an indexed PNG first.'); return; }
      const bytes = encodeIndexedPNG(indices, width, height, palette, trns);
      const blob = new Blob([bytes], {type:'image/png'});
      const a = document.createElement('a'); a.download='color_folded.png'; a.href=URL.createObjectURL(blob); document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(a.href), 4000);
    });

    // ---------- File / DnD load ----------
    fileInput.addEventListener('change', e=>{ const f=e.target.files&&e.target.files[0]; if(f) load(f); });
    ['dragenter','dragover'].forEach(ev=>drop.addEventListener(ev,e=>{e.preventDefault(); e.stopPropagation(); drop.classList.add('drag');}));
    ['dragleave','drop'].forEach(ev=>drop.addEventListener(ev,e=>{e.preventDefault(); e.stopPropagation(); drop.classList.remove('drag');}));
    drop.addEventListener('drop', e=>{ const f=e.dataTransfer.files&&e.dataTransfer.files[0]; if(f) load(f); });

    async function load(file){
      try{
        resetState();
        await loadImageAndIndices(file);
      } catch(err){ console.error(err); alert(err.message||String(err)); }
    }

    function resetState(){ width=height=0; indices=null; palette=null; trns=null; selA=selB=null; paletteEl.innerHTML=''; palInfo.textContent=''; imgMeta.textContent=''; ctx.clearRect(0,0,canvas.width,canvas.height); history.length=0; undoBtn.disabled=true; saveBtn.disabled=true; }

    // ---------- Undo ----------
    undoBtn.addEventListener('click', undo);

    // ---------- Demo image on startup ----------
    function buildSMSPalette(){ const steps=[0,85,170,255]; const pal=[]; for(let r of steps){ for(let g of steps){ for(let b of steps){ pal.push(r,g,b); } } } return new Uint8Array(pal); }
    function makeDemoIndexed(size=96){
      const pal = buildSMSPalette();
      const w=size,h=size; const idx=new Uint8Array(w*h);
      const colors=[1,5,10,20,40,60]; // some SMS entries
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          const zone=((x/16)|0)+(((y/16)|0)%6); idx[y*w+x]=colors[zone%colors.length];
        }
      }
      return {width:w,height:h, indices:idx, palette:pal, trns:null};
    }

    function loadDemo(){ const d=makeDemoIndexed(128); width=d.width; height=d.height; indices=d.indices; palette=d.palette; trns=d.trns; renderUI(); }

    // ---------- Self-tests (console only) ----------
    function runSelfTests(){
      const results=[]; const ok=(name,cond)=>results.push({name,pass:!!cond});
      try{
        // Test 1: PNG encoder writes valid signature
        const pal = new Uint8Array([0,0,0, 255,0,0]);
        const idx = new Uint8Array([0]);
        const png = encodeIndexedPNG(idx,1,1,pal,null);
        ok('PNG signature', png[0]===137 && png[1]===80 && png[2]===78 && png[3]===71 && png[4]===13 && png[5]===10 && png[6]===26 && png[7]===10);
        // Test 2: fold B->A remaps indices and blacks out B
        const testIdx = new Uint8Array([0,1,1,0]);
        const testPal = new Uint8Array([10,20,30, 200,210,220]);
        (function foldLocal(A,B,indicesLocal,palLocal){
          for(let i=0;i<indicesLocal.length;i++) if(indicesLocal[i]===B) indicesLocal[i]=A;
          palLocal[B*3]=0; palLocal[B*3+1]=0; palLocal[B*3+2]=0;
        })(0,1,testIdx,testPal);
        ok('Indices remapped', testIdx[1]===0 && testIdx[2]===0);
        ok('Palette B blacked', testPal[3]===0 && testPal[4]===0 && testPal[5]===0);
      } catch(e){ console.error('Self-test failed:', e); }
      const summary = results.map(r=>`${r.pass?'✅':'❌'} ${r.name}`).join('\n');
      console.log('[Color Folder self-tests]\n'+summary);
    }

    window.addEventListener('DOMContentLoaded', ()=>{ loadDemo(); runSelfTests(); });
  </script>
</body>
</html>
